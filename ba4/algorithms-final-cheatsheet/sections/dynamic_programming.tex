\fbox{
    \begin{minipage}[t]{1\linewidth}
      \textbf{Dynamic Programming}\\
      \begin{minipage}[t]{0.49\linewidth}
    \textbf{Problem:} Optimal solutions to overlapping subproblems\\
    \textbf{Fibonacci Sequence:}\\
    \textbf{Top-Down (Memoization):}\\
    1. Create memo array $F[0...n]$ initialized to NIL\\
    2. Base cases: $F[0] = 0$, $F[1] = 1$\\
    3. Recursive with memo:\\
    - Return $F[n]$ if already computed\\
    - Otherwise compute \\$F[n] = F[n-1] + F[n-2]$\\
    - Store result in $F[n]$ and return\\[-15px]
    \algocode{fib-memoized}\vspace*{-25px}
    \textbf{Bottom-Up (Tabulation):}\\
    1. Create array $F[0...n]$\\
    2. Base cases: $F[0] = 0$, $F[1] = 1$\\
    3. For $i = 2$ to $n$:\\
    - Compute $F[i] = F[i-1] + F[i-2]$\\
    4. Return $F[n]$\\[-15px]
    \algocode{fib-bottom-up}\vspace*{-20px}
    \textbf{Time Complexity:} $O(n)$\\
    \textbf{Space Complexity:} $O(n)$ \\(includes input and memo array)
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.49\linewidth}
    \textbf{Cut-Rod Problem:}\\
    Find optimal way to cut rod to maximize revenue\\
    \textbf{Top-Down (Memoization):}\\
    1. Create memo array $r[0...n]$ with $r[0] = 0$\\
    2. For uncalculated $r[j]$, compute:\\
    $r[j] = \max_{1\leq i\leq j}(p[i] + r[j-i])$\\
    3. Return $r[n]$\\[-17px]
    \algocode{rod-memoized}\vspace*{-25px}
    \textbf{Bottom-Up (Tabulation):}\\
    1. Create array $r[0...n]$ with $r[0] = 0$\\
    2. For $j = 1$ to $n$:\\
    - Compute $r[j] = \max_{1\leq i\leq j}(p[i] + r[j-i])$\\
    3. Return $r[n]$\\[-13px]
    \algocode{rod-bottom-up}\vspace*{-25px}
    \textbf{Time Complexity:} $O(n^2)$\\
    \textbf{Space Complexity:} $O(n)$ \\(includes input prices and array)
    \end{minipage}
    \end{minipage}
    }