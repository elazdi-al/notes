\fbox{
    \begin{minipage}[t]{1\linewidth}
    \textbf{Data Structure Operations Summary}\\
    \begin{minipage}[t]{1\linewidth}
    \textbf{Priority Queue Operations}\\
    \begin{tabular}{|p{0.19\linewidth}|p{0.37\linewidth}|p{0.168\linewidth}|p{0.04\linewidth}|}
    \hline
    \textbf{Operation} & \textbf{Description} & \textbf{Time} & \textbf{Space} \\
    \hline
    Construction & Create priority queue from array of n elements & $O(n)$ & $O(n)$ \\
    \hline
    Maximum(S) & Returns element with highest priority & $O(1)$ & $O(1)$ \\
    \hline
    Extract-Max(S) & Removes and returns element with highest priority & $O(\log n)$ & $O(1)$ \\
    \hline
    Insert(S, x) & Inserts element x into set S & $O(\log n)$ & $O(1)$ \\
    \hline
    Increase-Key(S, x, k) & Increases priority of element x to k & $O(\log n)$ & $O(1)$ \\
    \hline
    \end{tabular}\\
    \textbf{Stack Operations}\\
    \begin{tabular}{|p{0.19\linewidth}|p{0.37\linewidth}|p{0.168\linewidth}|p{0.04\linewidth}|}
    \hline
    \textbf{Operation} & \textbf{Description} & \textbf{Time} & \textbf{Space} \\
    \hline
    Construction & Create stack from array of n elements & $O(n)$ & $O(n)$ \\
    \hline
    Stack-Empty(S) & Returns TRUE if stack is empty, FALSE otherwise & $O(1)$ & $O(1)$ \\
    \hline
    Push(S, x) & Adds element x to top of stack S & $O(1)$ & $O(1)$ \\
    \hline
    Pop(S) & Removes and returns top element from stack S & $O(1)$ & $O(1)$ \\
    \hline
    \end{tabular}\\
    \textbf{Heap Operations}\\
    \begin{tabular}{|p{0.19\linewidth}|p{0.37\linewidth}|p{0.168\linewidth}|p{0.04\linewidth}|}
    \hline
    \textbf{Operation} & \textbf{Description} & \textbf{Time} & \textbf{Space} \\
    \hline
    Construction & Create heap from array of n elements & $O(n)$ & $O(n)$ \\
    \hline
    Max-Heapify(A, i) & Maintains max-heap property at node i & $O(\log n)$ & $O(1)$ \\
    \hline
    Build-Max-Heap(A,n) & Converts array A of n elements into max heap & $O(n)$ & $O(1)$ \\
    \hline
    Heap-Sort(A, n) & Sorts array A of n elements using heap structure & $O(n \log n)$ & $O(1)$ \\
    \hline
    Max-Heap-Insert(A, k) & Inserts key k into heap A & $O(\log n)$ & $O(1)$ \\
    \hline
    Heap-Extract-Max(A) & Returns and removes largest element from heap A & $O(\log n)$ & $O(1)$ \\
    \hline
    Heap-Increase-Key(A,i,k) & Increases key at index i to new value k & $O(\log n)$ & $O(1)$ \\
    \hline
    \end{tabular}\\
    \end{minipage}\\
    \begin{minipage}[t]{1\linewidth}
    \textbf{BST Operations}\\
    \begin{tabular}{|p{0.19\linewidth}|p{0.37\linewidth}|p{0.168\linewidth}|p{0.04\linewidth}|}
    \hline
    \textbf{Operation} & \textbf{Description} & \textbf{Time} & \textbf{Space} \\
    \hline
    Construction & Create BST from array of n elements & Best: $O(n\log n)$, Worst: $O(n^2)$ & $O(n)$ \\
    \hline
    BST-Search(T, k) & Finds node with key k in tree T & $O(h)$ & $O(h)$ \\
    \hline
    BST-Minimum(T) & Returns node with smallest key in T & $O(h)$ & $O(1)$ \\
    \hline
    BST-Maximum(T) & Returns node with largest key in T & $O(h)$ & $O(1)$ \\
    \hline
    BST-Successor(x) & Returns node with smallest key greater than x's key & $O(h)$ & $O(1)$ \\
    \hline
    BST-Insert(T, z) & Inserts node z into BST T & $O(h)$ & $O(1)$ \\
    \hline
    BST-Delete(T, z) & Removes node z from BST T & $O(h)$ & $O(1)$ \\
    \hline
    BST-Inorder(T) & Visits all nodes in sorted order & $O(n)$ & $O(h)$ \\
    \hline
    BST-Preorder(T) & Visits root before its children & $O(n)$ & $O(h)$ \\
    \hline
    BST-Postorder(T) & Visits children before root & $O(n)$ & $O(h)$ \\
    \hline
    \end{tabular}\\
    \textbf{ Queue Operations}\\
    \begin{tabular}{|p{0.19\linewidth}|p{0.37\linewidth}|p{0.168\linewidth}|p{0.04\linewidth}|}
    \hline
    \textbf{Operation} & \textbf{Description} & \textbf{Time} & \textbf{Space} \\
    \hline
    Construction & Create queue from array of n elements & $O(n)$ & $O(n)$ \\
    \hline
    Queue-Empty(Q) & Returns TRUE if queue is empty, FALSE otherwise & $O(1)$ & $O(1)$ \\
    \hline
    Enqueue(Q, x) & Adds element x to rear of queue Q & $O(1)$ & $O(1)$ \\
    \hline
    Dequeue(Q) & Removes and returns front element from queue Q & $O(1)$ & $O(1)$ \\
    \hline
    \end{tabular}\\
    \textbf{Linked List Operations}\\
    \begin{tabular}{|p{0.19\linewidth}|p{0.37\linewidth}|p{0.168\linewidth}|p{0.04\linewidth}|}
    \hline
    \textbf{Operation} & \textbf{Description} & \textbf{Time} & \textbf{Space} \\
    \hline
    Construction & Create linked list from array of n elements & $O(n)$ & $O(n)$ \\
    \hline
    List-Search(L, k) & Returns pointer to first node with key k, NULL if not found & $O(n)$ & $O(1)$ \\
    \hline
    List-Insert(L, x) & Inserts node x at beginning of list L & $O(1)$ & $O(1)$ \\
    \hline
    List-Delete(L, x) & Removes node x from list L & $O(n)$ find, $O(1)$ del & $O(1)$ \\
    \hline
    \end{tabular}\\
    \end{minipage}
    \end{minipage}
    }